# Messaging-Portal

**Messaging-Portal** is a specialized cryptographic tool designed to secure text communication through a hybrid approach of **arithmetic obfuscation** and **steganographic noise injection**. Unlike standard encryption which simply scrambles data, this tool hides encrypted payloads within massive arrays of deterministic random noise, making the extraction of data computationally expensive without the correct reconstruction logic.

---

## üåü Key Features

- **Hybrid Encryption Architecture**:
  - **Layer 1 (Value Obfuscation)**: ASCII-based XOR transformation using a modular key.
  - **Layer 2 (Structural Obfuscation)**: "Needle in a Haystack" expansion where data is hidden in a 256x noise field.
- **Deterministic Chaos**: Utilizes `numpy`'s random permutation engine seeded with message properties to create reproducible yet chaotic data structures.
- **Word-Level Granularity**: Processes messages word-by-word to preserve structural integrity while destroying semantic meaning.
- **Serialized Transport**: Outputs encrypted objects as Base64-encoded Python pickles, ready for file storage or network transmission.

---

## üîß Technical Architecture

The system operates on two distinct mathematical phases. Below is the step-by-step algorithmic breakdown found in the source code.

### 1. Encryption Logic (`Encriptions.py`)

The encryption process transforms a simple string into a complex nested integer array.

#### Phase A: The XOR Transformation

Before hiding the data, the character values are masked.

1. **Input**: A single word from the message.
2. **ASCII Conversion**: Characters are converted to their integer ordinals.
3. **Key Modulation**: The secret `key` is modulated to a 7-bit integer: `effective_key = key % 127`.
4. **Transformation**: Each character $C$ is transformed into $C'$:

$$C' = (C \oplus \text{effective\_key}) \ \& \ 0xFF$$

#### Phase B: The Expansion & Injection (The "256x" Rule)

This is the core obfuscation mechanism.

1. **Expansion Calculation**: For a word of length $L$, the system allocates an array of size $L \times 256$.
2. **Seeding**: The random number generator is seeded with **$L$** (the length of the word). This ensures that the specific shuffle pattern for a 5-letter word is always unique to 5-letter words but consistent across sessions.
3. **Permutation**: A shuffled array of indices $[0, 1, ..., (L \times 256) - 1]$ is generated.
4. **Injection Logic**:
   - The system iterates through the shuffled indices.
   - It checks the parity of the index (odd/even).
   - **Condition**: If `index` is **ODD** (`index % 2 == 1`) and there are characters left to hide, the encrypted character $C'$ is placed at this position.
   - **Noise**: If the condition fails, or if all characters are placed, the position is filled with a random "garbage" character selected from a pool of alphanumeric and special symbols (`Allcombine`).

---

### 2. Decryption Logic (`Decryption.py`)

Decryption does not require the user to know the specific noise positions; it mathematically reconstructs them.

1. **Length Derivation**: The system reads the total length of the encrypted array ($N$) and calculates the original word length: $L = N / 256$.
2. **Seed Reconstruction**: It re-seeds the random generator with $L$.
3. **Permutation Replay**: Because the seed is identical, `numpy` generates the exact same sequence of shuffled indices used during encryption.
4. **Extraction**: The system iterates through the recreated shuffle, selecting values only where `index % 2 == 1`.
5. **Reversal**: The extracted integers are XOR-ed back with `key % 127` to reveal the original text.

---

## üì¶ Data Artifacts

### `Encription_Data.log`

This file is the primary artifact generated by the tool. It is **not** human-readable text.

- **Format**: Base64-encoded string.
- **Content**: A serialized Python list (via `pickle`) containing sub-lists of integers.
- **Structure**: `[[int, int, ...], [int, int, ...]]` where each sub-list represents one word expanded 256 times.

---

## üíª Installation & Setup

### Prerequisites

- **Python 3.8+**
- **NumPy**: Essential for the permutation logic.

```bash
pip install numpy
```

### File Setup

Ensure the following files are in the same directory:

- `Encriptions.py` ‚Äî The encryption engine.
- `Decryption.py` ‚Äî The decryption engine.
- `test.py` ‚Äî (Optional) For testing the pipeline.

---

## üöÄ Usage API

### Encrypting Data

To encrypt data, instantiate the `Encriptions` class. This triggers the encryption pipeline immediately.

```python
import Encriptions as en

# The key can be any large integer.
# Note: Only the modulo 127 of this key affects the XOR phase.
secret_key = 987654321
message = "Hello World"

# Initialization runs the encryption and writes to 'Encription_Data.log'
en.Encriptions(message, secret_key)
```

### Decrypting Data

To decrypt, provide the exact same key used for encryption. The script looks for `Encription_Data.log` automatically.

```python
import Decryption as de

secret_key = 987654321

# Initialization reads the log file and prints the decrypted message
de.Decryption(secret_key)
```

### Running the Integrated Test

A `test.py` script is included to verify the environment. It generates a random 256-bit integer key, encrypts a block of source code, and validates the decryption.

```bash
python test.py
```

---

## ‚ö†Ô∏è Limitations & Security Notice

- **Key Strength**: While the input key can be large, the effective key space for the XOR operation is limited to $0$‚Äì$126$ (`key % 127`). The primary security comes from the complexity of the data expansion, not the XOR cipher.
- **Deterministic Shuffling**: The shuffle pattern relies on `word_length`. This means any two words of the same length (e.g., `"Apple"` and `"Grape"`) will hide their real characters at the exact same array indices, though the noise surrounding them will differ.
- **File Dependency**: The system strictly reads/writes to `Encription_Data.log`. Concurrent executions will overwrite this file.
